#!/usr/bin/env bash
# run reloadExtensions to reload



# Displays all nodes in the cluster including kubernetes version info
alias nodes="k get nodes -o=custom-columns='Name:.metadata.name,IP:.status.addresses[0].address,Kubelet:.status.nodeInfo.kubeletVersion,Taints:.spec.taints[*],STATUS:.status.conditions[?(@.status==\"True\")].type,CPU:.status.allocatable.cpu,MEM:.status.allocatable.memory'"

# Force a deletion
alias deletef="k delete --grace-period=0 --force"

# Get events in order
alias events="k get events --sort-by='{.lastTimestamp}'"

# get images that pods use in your namespace with a count
alias pod-images="k get pods --no-headers -o=custom-columns='Images:.spec.containers[*].image' | tr ',' '\n' | sort | uniq -c"

# get pods and their images sorted by image
alias pods-with-image="k get pods --no-headers -o=go-template --template='{{range .items}}{{\$pod := .metadata.name}}{{range .spec.containers}}{{\$pod}}{{\"\t\"}}{{.name}}{{\"\t\"}}{{.image }}{{\"\n\"}}{{end}}{{end}}' | sort -k 3"

# get overall pod status report
alias pod-report="k get pods --all-namespaces --no-headers -o=custom-columns='Status:.status.phase' | sort | uniq -c"

# get pods that are current leaders
alias leaders="k get ep -o json | jq '.items[].metadata.annotations[\"control-plane.alpha.kubernetes.io/leader\"] | select(.!=null)' -r | jq '.holderIdentity | split(\"_\")[0]' -r"

# get nodes allocateable resources
alias node-allocateable="kubectl describe nodes | grep -A 2 -e'^Name:' -e'^Allocatable:' -e '^\\s*CPU Requests'"

# select context
cts() {
  ct=$(k config get-contexts -o name | fzf)
  ct "$ct"
}

# select namespace
nss() {
  ns=$(get namespaces -o custom-columns=NAME:metadata.name --no-headers | fzf)
  ns "$ns"
}

# select pod for logs
logss() {
  pod=$(get pods --no-headers | fzf | awk '{print $1}')
  container=$(get pods "$pod" -o=jsonpath="{.spec.containers[*].name}" | tr ' ' '\n' | fzf -1)
  logs "$pod" -c "$container" "$@"
}

alias pods='k get pods'

all-pods() {
  k get pods --all-namespaces "$@"
}

ssh-nodes() {
  SSH_ARGS="${*}"
  k get nodes --no-headers -o json | jq '.items[].status.addresses[0].address' -r | \
    xargs -INODE -n1 -P1 sh -c "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${K8S_SSH_USER-core}@NODE ${SSH_ARGS} | sed -e 's/^/NODE:\t/'"
}

alias restart-all='k patch --patch "{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"updated\":\"$(date +%s)\"}}}}}"'

nodeips() {
  k get nodes -o jsonpath='{.items[*].status.addresses[?\(@.type==\"ExternalIP\"\)].address}'
}

get-all() {
  k get $(k api-resources --no-headers | awk '{ print $1 }' | tr '\n' ',' | sed 's/,$/\n/')
}

namesof() {
  local type=${1:-'pods'}
  k get --no-headers "$type" | awk '{ print $1 }' | tr '\n' ',' | sed 's/,$/\n/'
}

namesofgrep() {
  local search=${1:-'-'}
  local type=${2:-'pods'}
  k get --no-headers -o wide "$type" | grep "$search" | awk '{ print $1 }' | tr '\n' ',' | sed 's/,$/\n/'
}

# output cert as text
readcert() {
  k get secrets -o json "$@" | jq '.data["tls.crt"]' -r | base64 -d | openssl x509 -in /dev/stdin -text -noout
}

readkey() {
  k get secrets -o json "$@" | jq '.data["tls.key"]' -r | base64 -d | openssl rsa -in /dev/stdin -text -noout
}

checkcacert() {
  openssl verify -trusted <(k get secrets -o json "$1" | jq '.data["tls.crt"]' -r | base64 -d | openssl x509 -in /dev/stdin -modulus -noout)
  k get secrets -o json "$1" | jq '.data["tls.key"]' -r | base64 -d | openssl rsa -in /dev/stdin -modulus -noout | openssl md5
  k get secrets -o json "$2" | jq '.data["tls.crt"]' -r | base64 -d | openssl x509 -in /dev/stdin -modulus -noout | openssl md5
}

readistiocert() {
  k get secrets -o json "$@" | jq '.data["root-cert.pem"]' -r | base64 -d | openssl x509 -in /dev/stdin -text -noout
}

# add grep to pods/nodes listing, eg:
# $ pods? -v Running
# $ nodes? cr2
# $ pods-with-image? hyperkube
alias pods\?="pods -o wide | grep"
alias all-pods\?="all-pods -o wide | grep"
alias nodes\?="nodes | grep"
alias pod-images\?="pod-images | grep"
alias pods-with-image\?="pods-with-image | grep"
alias leaders\?="leaders | grep"
alias get-all\?="get-all | grep"

# Pick a random node in Ready state
get-random-node() {
  k get nodes | grep ' Ready' | awk '{ print $1 }' | shuf -n 1
}

# Show pods that don't have all containers ready
alias brokenpods='k get pod --all-namespaces | grep -vE '\''([0-9]+)/\1'\'''

# Runs a busybox container (optionally selecting the a specific node to run on)
# and shells into it.
toolbox() {
  local NODENAME=${1-null}
  delete po/toolbox
  cat <<EOF | k apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: toolbox
spec:
  containers:
  - name: toolbox
    image: mirror-releases.docker.ospcfc.tech.lastmile.com/osp-cfc-platform/toolbox:0.0.4
    command:
      - sleep
      - "3600"
    volumeMounts:
    - name: tmp
      mountPath: /tmp
    imagePullPolicy: IfNotPresent
  nodeName: ${NODENAME}
  restartPolicy: Always
  volumes:
  - name: tmp
    hostPath:
      path: /tmp
EOF
}

# Runs a temporary kube-scheduler
# Assumes self hosting setup
temp-scheduler() {
  delete pod/temp-scheduler
  k --namespace kube-system get deployment kube-scheduler -o json | jq '.spec.template * {"kind": "Pod", "apiVersion": "v1", "metadata": {"name": "temp-scheduler", "namespace": "kube-system", "labels": {"k8s-app": "temp-scheduler"}}}'| jq ".spec.nodeName = \"$(get-random-node)\"" | kubectl create -f -
}

# Runs a temporary kube-controller-manager
# Assumes self hosting setup
temp-controller-manager() {
  delete pod/temp-controller-manager
  k --namespace kube-system get deployment kube-controller-manager -o json | jq '.spec.template * {"kind": "Pod", "apiVersion": "v1", "metadata": {"name": "temp-controller-manager", "namespace": "kube-system", "labels": {"k8s-app": "temp-controller-manager"}}}' | jq ".spec.nodeName = \"$(get-random-node)\"" | kubectl create -f -
}

# removes the temporary scheduler and controller manager when not required
delete-temp-components() {
  U=""
  if [[ "$KUSER" ]]; then
    U="--user=$KUSER"
  fi
  delete "$U" pod/temp-scheduler
  delete "$U" pod/temp-controller-manager
}
